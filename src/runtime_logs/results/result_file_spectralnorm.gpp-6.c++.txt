{
    "0": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <emmintrin.h>\n\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 1 < end; i += 2) {\n        __m128d sum = _mm_set_pd(\n\t\t\tsrc[0] / double(Index<modei>(i + 1, 0)),\n\t\t\tsrc[0] / double(Index<modei>(i + 0, 0)));\n    \n\t\t__m128d ti = modei?\n\t\t\t_mm_set_pd(i + 1, i + 0) :\n\t\t\t_mm_set_pd(i + 2, i + 1);\t\n\t\t__m128d last = _mm_set_pd(\n\t\t\tIndex<modei>(i + 1, 0),\n\t\t\tIndex<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n\t\t\t__m128d idx = last + ti + _mm_set1_pd(j);\n\t\t\tlast = idx;\n            sum = sum + _mm_set1_pd(src[j]) / idx;\n        }\n\n        _mm_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(16))) double u[N];\n    __attribute__((aligned(16))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp critical\n        {\n            vBv += sumvb;\n            vv += sumvv;\n        }\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        138.375,
        838.857
    ],
    "1": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>  // Updated to include AVX\n\n// Adapt the Index function, no change needed for optimization\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei? i : j) + 1;\n}\n\n// Use AVX in EvalPart\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst,\n                int begin, int end, int length) {\n    int i = begin;\n\n    for(; i + 3 < end; i += 4) {  // Process 4 elements at a time\n        __m256d sum = _mm256_set_pd(\n            src[0] / double(Index<modei>(i + 3, 0)),\n            src[0] / double(Index<modei>(i + 2, 0)),\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n    \n        __m256d ti = modei?\n            _mm256_set_pd(i + 3, i + 2, i + 1, i + 0) :\n            _mm256_set_pd(i + 4, i + 3, i + 2, i + 1);\n        __m256d last = _mm256_set_pd(\n            Index<modei>(i + 3, 0),\n            Index<modei>(i + 2, 0),\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for(int j = 1; j < length; j++) {\n            __m256d idx = last + ti + _mm256_set1_pd(j);\n            last = idx;\n            sum = sum + _mm256_set1_pd(src[j]) / idx;\n        }\n\n        _mm256_storeu_pd(dst + i + 0, sum);\n    }\n    for(; i < end; i++) {  // Fall back to scalar processing\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp,\n                   int begin, int end, int N) {\n    EvalATimesU (src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(32))) double u[N];  // Align to 32 for AVX\n    __attribute__((aligned(32))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for(int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}\n",
        98.727,
        598.446
    ],
    "2": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>  // Use AVX for optimizations\n\n// Adapt the Index function as required\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Use AVX in EvalPart\ntemplate <bool modei>\nvoid EvalPart(double *src, double *dst, int begin, int end, int length) {\n    int blockSize = 4;  // Define block size for cache efficiency\n    for(int b = begin; b < end; b += blockSize) {\n        int iEnd = std::min(b + blockSize, end);\n        for (int i = b; i < iEnd; i++) {\n            double sum = 0.0;\n            for (int j = 0; j < length; j++)\n                sum += src[j] / double(Index<modei>(i, j));\n            dst[i] = sum;\n        }\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\n// Main spectral game function\ndouble spectral_game(int N) {\n    __attribute__((aligned(32))) double u[N];  // Align data for AVX\n    __attribute__((aligned(32))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount - 1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; i++)\n            u[i] = 1.0;\n\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n\n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}\n",
        190.75,
        1156.42
    ],
    "3": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>\n\n// Adapt the Index function\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Use AVX for optimal processing\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length) {\n    int i;\n    for (i = begin; i + 3 < end; i += 4) {\n        __m256d sum = _mm256_set_pd(\n            src[0] / double(Index<modei>(i + 3, 0)),\n            src[0] / double(Index<modei>(i + 2, 0)),\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n\n        __m256d ti = modei ?\n            _mm256_set_pd(i + 3, i + 2, i + 1, i + 0) :\n            _mm256_set_pd(i + 4, i + 3, i + 2, i + 1);\n\n        __m256d last = _mm256_set_pd(\n            Index<modei>(i + 3, 0),\n            Index<modei>(i + 2, 0),\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for (int j = 1; j < length; j++) {\n            __m256d idx = last + ti + _mm256_set1_pd(j);\n            last = idx;\n            sum = sum + _mm256_set1_pd(src[j]) / idx;\n        }\n\n        _mm256_storeu_pd(dst + i, sum);\n    }\n    for (; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(32))) double u[N];  // Align for AVX\n    __attribute__((aligned(32))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        100.414,
        608.767
    ],
    "4": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>\n\n// Adapt the Index function\ntemplate <bool modei> int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\n// Use AVX-512 for optimal processing\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length) {\n    int i;\n    for (i = begin; i + 7 < end; i += 8) {\n        __m512d sum = _mm512_set_pd(\n            src[0] / double(Index<modei>(i + 7, 0)),\n            src[0] / double(Index<modei>(i + 6, 0)),\n            src[0] / double(Index<modei>(i + 5, 0)),\n            src[0] / double(Index<modei>(i + 4, 0)),\n            src[0] / double(Index<modei>(i + 3, 0)),\n            src[0] / double(Index<modei>(i + 2, 0)),\n            src[0] / double(Index<modei>(i + 1, 0)),\n            src[0] / double(Index<modei>(i + 0, 0)));\n\n        __m512d ti = modei ?\n            _mm512_set_pd(i + 7, i + 6, i + 5, i + 4, i + 3, i + 2, i + 1, i + 0) :\n            _mm512_set_pd(i + 8, i + 7, i + 6, i + 5, i + 4, i + 3, i + 2, i + 1);\n\n        __m512d last = _mm512_set_pd(\n            Index<modei>(i + 7, 0),\n            Index<modei>(i + 6, 0),\n            Index<modei>(i + 5, 0),\n            Index<modei>(i + 4, 0),\n            Index<modei>(i + 3, 0),\n            Index<modei>(i + 2, 0),\n            Index<modei>(i + 1, 0),\n            Index<modei>(i + 0, 0));\n\n        for (int j = 1; j < length; j++) {\n            __m512d idx = last + ti + _mm512_set1_pd(j);\n            last = idx;\n            sum = sum + _mm512_set1_pd(src[j]) / idx;\n        }\n\n        _mm512_storeu_pd(dst + i, sum);\n    }\n    for (; i < end; i++) {\n        double sum = 0;\n        for (int j = 0; j < length; j++)\n            sum += src[j] / double(Index<modei>(i, j));\n        dst[i] = sum;\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    __attribute__((aligned(64))) double u[N];  // Align for AVX-512\n    __attribute__((aligned(64))) double v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        89.086,
        540.029
    ],
    "5": [
        "#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <sched.h>\n#include <omp.h>\n#include <immintrin.h>\n\ntemplate <bool modei> inline int Index(int i, int j) {\n    return (((i + j) * (i + j + 1)) >> 1) + (modei ? i : j) + 1;\n}\n\ntemplate <bool modei>\nvoid EvalPart(double *__restrict__ src, double *__restrict__ dst, int begin, int end, int length) {\n    int i;\n    #pragma omp parallel for schedule(static)\n    for (i = begin; i < end; i++) {\n        __m512d sum = _mm512_setzero_pd();\n        for (int j = 0; j < length; j += 8) {\n            __m512d idx = _mm512_set_pd(\n                Index<modei>(i, j+7),\n                Index<modei>(i, j+6),\n                Index<modei>(i, j+5),\n                Index<modei>(i, j+4),\n                Index<modei>(i, j+3),\n                Index<modei>(i, j+2),\n                Index<modei>(i, j+1),\n                Index<modei>(i, j+0));\n            __m512d src_val = _mm512_loadu_pd(&src[j]);\n            sum = _mm512_add_pd(sum, _mm512_div_pd(src_val, idx));\n        }\n        dst[i] = _mm512_reduce_add_pd(sum);\n    }\n}\n\nvoid EvalATimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<1>(src, dst, begin, end, N);\n}\n\nvoid EvalAtTimesU(double *src, double *dst, int begin, int end, int N) {\n    EvalPart<0>(src, dst, begin, end, N);\n}\n\nvoid EvalAtATimesU(double *src, double *dst, double *tmp, int begin, int end, int N) {\n    EvalATimesU(src, tmp, begin, end, N);\n    #pragma omp barrier\n    EvalAtTimesU(tmp, dst, begin, end, N);\n    #pragma omp barrier\n}\n\nint GetThreadCount() {\n    cpu_set_t cs;\n    CPU_ZERO(&cs);\n    sched_getaffinity(0, sizeof(cs), &cs);\n\n    int count = 0;\n    for (int i = 0; i < CPU_SETSIZE; ++i)\n        if (CPU_ISSET(i, &cs))\n            ++count;\n\n    return count;\n}\n\ndouble spectral_game(int N) {\n    alignas(64) double u[N], v[N], tmp[N];\n\n    double vBv = 0.0;\n    double vv = 0.0;\n\n    #pragma omp parallel default(shared) num_threads(GetThreadCount())\n    {\n        int threadid = omp_get_thread_num();\n        int threadcount = omp_get_num_threads();\n        int chunk = N / threadcount;\n\n        int begin = threadid * chunk;\n        int end = (threadid < (threadcount -1)) ? (begin + chunk) : N;\n\n        for (int i = begin; i < end; i++)\n            u[i] = 1.0;\n        #pragma omp barrier\n\n        for (int ite = 0; ite < 10; ++ite) {\n            EvalAtATimesU(u, v, tmp, begin, end, N);\n            EvalAtATimesU(v, u, tmp, begin, end, N);\n        }\n    \n        double sumvb = 0.0, sumvv = 0.0;\n        for (int i = begin; i < end; i++) {\n            sumvv += v[i] * v[i];\n            sumvb += u[i] * v[i];\n        }\n\n        #pragma omp atomic\n        vBv += sumvb;\n        #pragma omp atomic\n        vv += sumvv;\n    }\n\n    return sqrt(vBv / vv);\n}\n\nint main(int argc, char *argv[]) {\n    int N = ((argc >= 2) ? atoi(argv[1]) : 2000);\n    printf(\"%.9f\\n\", spectral_game(N));\n    return 0;\n}",
        181.75,
        1101.772
    ]
}