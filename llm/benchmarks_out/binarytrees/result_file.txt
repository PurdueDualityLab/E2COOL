{
    "0": [
        "#include <iostream>\n#include <stdlib.h>\n#include <stdio.h>\n#include <apr_pools.h>\n\n\nconst size_t    LINE_SIZE = 64;\n\nclass Apr\n{\npublic:\n    Apr() \n    {\n        apr_initialize();\n    }\n\n    ~Apr() \n    {\n        apr_terminate();\n    }\n};\n\nstruct Node \n{\n    Node *l, *r;\n    \n    int check() const \n    {\n        if (l)\n            return l->check() + 1 + r->check();\n        else return 1;\n    }\n};\n\nclass NodePool\n{\npublic:\n    NodePool() \n    {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() \n    {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc()\n    {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear()\n    {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store)\n{\n    Node* root = store.alloc();\n\n    if(d>0){\n        root->l=make(d-1, store);\n        root->r=make(d-1, store);\n    }else{\n        root->l=root->r=0;\n    }\n\n    return root;\n}\n\nint main(int argc, char *argv[]) \n{\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2,\n                             (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth+1;\n\n    // Alloc then dealloc stretchdepth tree\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // buffer to store output of each thread\n    char *outputstr = (char*)malloc(LINE_SIZE * (max_depth +1) * sizeof(char));\n\n    #pragma omp parallel for \n    for (int d = min_depth; d <= max_depth; d += 2) \n    {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) \n        {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // each thread write to separate location\n        sprintf(outputstr + LINE_SIZE * d, \"%d\\t trees of depth %d\\t check: %d\\n\",\n           iterations, d, c);\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) \n        printf(\"%s\", outputstr + (d * LINE_SIZE) );\n    free(outputstr);\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << (long_lived_tree->check()) << \"\\n\";\n\n    return 0;\n}",
        85.766,
        761.574
    ],
    "1": [
        "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <apr_pools.h>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() {\n        apr_initialize();\n    }\n\n    ~Apr() {\n        apr_terminate();\n    }\n};\n\nstruct Node {\n    Node *l, *r;\n\n    // Improved check function that reduces branching\n    int check() const {\n        int result = 1;\n        if (l) {\n            result += l->check() + r->check();\n        }\n        return result;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool() {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc() {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear() {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store) {\n    Node* root = store.alloc();\n\n    root->l = root->r = nullptr;\n    if(d > 0) {\n        root->l = make(d-1, store);\n        root->r = make(d-1, store);\n    }\n    return root;\n}\n\nint main(int argc, char *argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Use of scope to reduce memory usage duration\n    {\n        NodePool store;\n        Node *c = make(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store);\n\n    // Use vector instead of raw buffer for safety\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node *a = make(d, store);\n            c += a->check();\n            store.clear();\n        }\n\n        // Use string streams to construct outputs safely\n        outputs[d] = std::to_string(iterations) + \"\\t trees of depth \" + std::to_string(d) + \"\\t check: \" + std::to_string(c) + \"\\n\";\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        std::cout << outputs[d];\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        90.267,
        794.745
    ],
    "2": [
        "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <apr_pools.h>\n#include <omp.h>\n\nconst size_t LINE_SIZE = 64;\n\nclass Apr {\npublic:\n    Apr() {\n        apr_initialize();\n    }\n\n    ~Apr() {\n        apr_terminate();\n    }\n};\n\nstruct Node {\n    Node *l, *r;\n\n    // Improved check function that reduces branching\n    int check() const {\n        int result = 1;\n        if (l) {\n            result += l->check() + r->check();\n        }\n        return result;\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool() {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc() {\n        return (Node *)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear() {\n        apr_pool_clear(pool);\n    }\n\nprivate:\n    apr_pool_t* pool;\n};\n\nNode *make(int d, NodePool &store, Node* &root_reuse) {\n    if (root_reuse) {\n        if (d == 0) {\n            root_reuse->l = root_reuse->r = nullptr;\n            return root_reuse;\n        }\n        Node* left = make(d-1, store, root_reuse->l);\n        Node* right = make(d-1, store, root_reuse->r);\n        root_reuse->l = left;\n        root_reuse->r = right;\n        return root_reuse;\n    }\n\n    Node* root = store.alloc();\n    if(d > 0) {\n         root->l = make(d-1, store, root->l);\n         root->r = make(d-1, store, root->r);\n    }\n    return root;\n}\n\nint main(int argc, char *argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth+2, (argc == 2 ? atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    // Use of scope to reduce memory usage duration\n    {\n        NodePool store;\n        Node *root_reuse = nullptr;\n        Node *c = make(stretch_depth, store, root_reuse);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    Node *long_lived_tree = make(max_depth, long_lived_store, long_lived_tree);\n\n    // Use vector instead of raw buffer for safety\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        // Create a memory pool for this thread to use.\n        NodePool store;\n        Node *root_reuse = nullptr;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node *a = make(d, store, root_reuse);\n            c += a->check();\n            store.clear();\n        }\n\n        // Use string streams to construct outputs safely\n        outputs[d] = std::to_string(iterations) + \"\\t trees of depth \" + std::to_string(d) + \"\\t check: \" + std::to_string(c) + \"\\n\";\n    }\n\n    // print all results\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        std::cout << outputs[d];\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        66.628,
        671.155
    ],
    "3": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <unordered_map>\n#include <apr_pools.h>\n#include <omp.h>\n\nclass Apr {\npublic:\n    Apr() {\n        apr_initialize();\n    }\n\n    ~Apr() {\n        apr_terminate();\n    }\n};\n\nstruct Node {\n    Node* l, *r;\n\n    int check() const {\n        if (!l) return 1;\n        return 1 + l->check() + r->check();\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool() {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc() {\n        incrementAllocation(sizeof(Node));\n        return (Node*)apr_palloc(pool, sizeof(Node));\n    }\n\n    void clear() {\n        if (bytesAllocated > threshold) {\n            apr_pool_clear(pool);\n        }\n        bytesAllocated = 0; // Reset counter after clear\n    }\n\n    void incrementAllocation(size_t size) {\n        bytesAllocated += size;\n    }\n\n    // Accessor methods for private members\n    size_t getBytesAllocated() const {\n        return bytesAllocated;\n    }\n\n    size_t getThreshold() const {\n        return threshold;\n    }\n\nprivate:\n    apr_pool_t* pool;\n    const size_t threshold = 1024 * 1024;  // Threshold for pool clear\n    size_t bytesAllocated = 0;\n};\n\nNode* makeNode(int d, NodePool& store, std::unordered_map<int, Node*>& cache) {\n    if (d == 0) {\n        return store.alloc();\n    }\n\n    if (cache.find(d) != cache.end()) {\n        return cache[d]; // Return cached node\n    }\n\n    Node* root = store.alloc();\n    root->l = makeNode(d - 1, store, cache);\n    root->r = makeNode(d - 1, store, cache);\n\n    cache[d] = root; // Cache the current depth node\n    \n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        std::unordered_map<int, Node*> cache; // Cache for nodes\n        Node* c = makeNode(stretch_depth, store, cache);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::unordered_map<int, Node*> long_cache;\n    Node* long_lived_tree = makeNode(max_depth, long_lived_store, long_cache);\n\n    std::vector<std::string> outputs(max_depth + 1);\n\n    #pragma omp parallel for schedule(dynamic)\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        NodePool store;\n        std::unordered_map<int, Node*> cache; // Cache for nodes\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = makeNode(d, store, cache);\n            c += a->check();\n\n            if (store.getBytesAllocated() > store.getThreshold() / 2) {\n                store.clear();\n            }\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n        outputs[d] = oss.str();\n    }\n\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        std::cout << outputs[d];\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}",
        29.041,
        387.45
    ],
    "4": [
        "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <unordered_map>\n#include <apr_pools.h>\n#include <omp.h>\n\nclass Apr {\npublic:\n    Apr() {\n        apr_initialize();\n    }\n    ~Apr() {\n        apr_terminate();\n    }\n};\n\nstruct Node {\n    Node* l, *r;\n    int check() const {\n        if (!l) return 1;\n        return 1 + l->check() + r->check();\n    }\n};\n\nclass NodePool {\npublic:\n    NodePool() {\n        apr_pool_create_unmanaged(&pool);\n    }\n\n    ~NodePool() {\n        apr_pool_destroy(pool);\n    }\n\n    Node* alloc() {\n        incrementAllocation(sizeof(Node));\n        return static_cast<Node*>(apr_palloc(pool, sizeof(Node)));\n    }\n\n    void clear() {\n        if (bytesAllocated > threshold) {\n            apr_pool_clear(pool);\n            bytesAllocated = 0;\n        }\n    }\n\n    void incrementAllocation(size_t size) {\n        bytesAllocated += size;\n    }\n\n    size_t getBytesAllocated() const {\n        return bytesAllocated;\n    }\n\n    size_t getThreshold() const {\n        return threshold;\n    }\n\nprivate:\n    apr_pool_t* pool;\n    const size_t threshold = 1024 * 1024;\n    size_t bytesAllocated = 0;\n};\n\nNode* makeNode(int d, NodePool& store, std::unordered_map<int, Node*>& cache) {\n    if (d == 0) {\n        return store.alloc();\n    }\n\n    if (cache.find(d) != cache.end()) {\n        return cache[d];\n    }\n\n    Node* root = store.alloc();\n    root->l = makeNode(d - 1, store, cache);\n    root->r = makeNode(d - 1, store, cache);\n\n    cache[d] = root;\n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    Apr apr;\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    {\n        NodePool store;\n        std::unordered_map<int, Node*> cache;\n        Node* c = makeNode(stretch_depth, store, cache);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    NodePool long_lived_store;\n    std::unordered_map<int, Node*> long_cache;\n    Node* long_lived_tree = makeNode(max_depth, long_lived_store, long_cache);\n\n    std::vector<std::string> outputs(max_depth / 2 + 1);\n\n    #pragma omp parallel for schedule(static)\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        NodePool store;\n        std::unordered_map<int, Node*> cache;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = makeNode(d, store, cache);\n            c += a->check();\n\n            if (store.getBytesAllocated() > store.getThreshold()) {\n                store.clear();\n            }\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << \"\\n\";\n        outputs[(d - min_depth) / 2] = oss.str();\n    }\n\n    for (const auto& output : outputs) {\n        std::cout << output;\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << \"\\n\";\n\n    return 0;\n}\n",
        27.415,
        349.469
    ],
    "5": [
        "\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <unordered_map>\n#include <omp.h>\n\nclass Node {\npublic:\n    Node() : l(nullptr), r(nullptr) {}\n    Node* l;\n    Node* r;\n    int check() const {\n        if (!l) return 1;\n        return 1 + l->check() + r->check();\n    }\n};\n\nclass NodePool {\npublic:\n    Node* alloc() {\n        Node *n = new Node();\n        allocatedNodes.push_back(n);\n        return n;\n    }\n\n    ~NodePool() {\n        for (Node *n : allocatedNodes) {\n            delete n;\n        }\n        allocatedNodes.clear();\n    }\n\nprivate:\n    std::vector<Node*> allocatedNodes;\n};\n\nbool useCache;\nstd::unordered_map<int, Node*> cache;\n\nNode* makeNode(int d, NodePool& store) {\n    if (d == 0) {\n        return store.alloc();\n    }\n\n    if (useCache && cache.find(d) != cache.end()) {\n        return cache[d];\n    }\n\n    Node* root = store.alloc();\n    root->l = makeNode(d - 1, store);\n    root->r = makeNode(d - 1, store);\n\n    if (useCache) {\n        cache[d] = root;\n    }\n\n    return root;\n}\n\nint main(int argc, char* argv[]) {\n    int min_depth = 4;\n    int max_depth = std::max(min_depth + 2, (argc == 2 ? std::atoi(argv[1]) : 10));\n    int stretch_depth = max_depth + 1;\n\n    useCache = true;  // Enable caching\n\n    {\n        NodePool store;\n        Node* c = makeNode(stretch_depth, store);\n        std::cout << \"stretch tree of depth \" << stretch_depth << \"\\t \"\n                  << \"check: \" << c->check() << std::endl;\n    }\n\n    useCache = false; // Reset cache\n    NodePool long_lived_store;\n    Node* long_lived_tree = makeNode(max_depth, long_lived_store);\n\n    std::vector<std::string> outputs((max_depth - min_depth) / 2 + 1);\n\n    #pragma omp parallel for schedule(static)\n    for (int d = min_depth; d <= max_depth; d += 2) {\n        int iterations = 1 << (max_depth - d + min_depth);\n        int c = 0;\n\n        NodePool store;\n        useCache = false;\n\n        for (int i = 1; i <= iterations; ++i) {\n            Node* a = makeNode(d, store);\n            c += a->check();\n        }\n\n        std::ostringstream oss;\n        oss << iterations << \"\\t trees of depth \" << d << \"\\t check: \" << c << std::endl;\n        outputs[(d - min_depth) / 2] = oss.str();\n    }\n\n    for (const auto& output : outputs) {\n        std::cout << output;\n    }\n\n    std::cout << \"long lived tree of depth \" << max_depth << \"\\t \"\n              << \"check: \" << long_lived_tree->check() << std::endl;\n\n    return 0;\n}\n",
        1060.112,
        8676.514
    ]
}